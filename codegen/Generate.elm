module Generate exposing (main)

{-| RPC Endpoint Generator

Generates RPC wrapper functions from endpoint definitions.

Reads endpoint configurations from endpoints.json (generated by scan-rpc-endpoints.js)

-}

import Elm
import Elm.Annotation as Type
import Gen.Basics
import Gen.CodeGen.Generate as Generate
import Json.Decode as Decode


main : Program Decode.Value () ()
main =
    Generate.fromJson
        decodeEndpoints
        (\endpoints ->
            [ generateRPCEndpoints endpoints
            ]
        )


{-| Endpoint configuration
-}
type alias EndpointConfig =
    { name : String
    , moduleName : String
    , functionName : String
    , paramTypes : List String
    , outputType : String
    , sourceFile : String
    }


{-| JSON decoder for endpoint configurations
-}
decodeEndpoints : Decode.Decoder (List EndpointConfig)
decodeEndpoints =
    Decode.list decodeEndpoint


decodeEndpoint : Decode.Decoder EndpointConfig
decodeEndpoint =
    Decode.map6 EndpointConfig
        (Decode.field "name" Decode.string)
        (Decode.field "moduleName" Decode.string)
        (Decode.field "functionName" Decode.string)
        (Decode.field "paramTypes" (Decode.list Decode.string))
        (Decode.field "outputType" Decode.string)
        (Decode.field "sourceFile" Decode.string)


{-| Generate the RPC endpoints file
-}
generateRPCEndpoints : List EndpointConfig -> Elm.File
generateRPCEndpoints endpoints =
    Elm.file [ "GeneratedRPC" ]
        [ generateRouterFunction endpoints
        , generateEndpointsList endpoints
        ]


{-| Generate the router function that dispatches to endpoints
Generates simple if-then-else chain for routing
-}
generateRouterFunction : List EndpointConfig -> Elm.Declaration
generateRouterFunction endpoints =
    let
        typeAnnotation =
            Type.function
                [ Type.var "a"
                , Type.named [ "LamderaRPC" ] "HttpRequest"
                , Type.named [ "Types" ] "BackendModel"
                ]
                (Type.triple
                    (Type.named [ "LamderaRPC" ] "RPCResult")
                    (Type.named [ "Types" ] "BackendModel")
                    (Type.namedWith [] "Cmd" [ Type.named [ "Types" ] "BackendMsg" ])
                )

        body =
            Elm.functionReduced "rawReq"
                (\rawReq ->
                    Elm.functionReduced "args"
                        (\args ->
                            Elm.functionReduced "model"
                                (\model -> generateRoutingLogic endpoints)
                        )
                )
    in
    Elm.declaration "handleGeneratedEndpoints"
        (Elm.withType typeAnnotation body)
        |> Elm.expose


{-| Generate routing logic as nested if-then-else expressions
TODO: @rpc endpoints need proper JSON encoding/decoding wrappers
-}
generateRoutingLogic : List EndpointConfig -> Elm.Expression
generateRoutingLogic endpoints =
    -- Return "not implemented" error for all generated endpoints
    Elm.triple
        (Elm.apply
            (Elm.value
                { importFrom = [ "LamderaRPC" ]
                , name = "failWith"
                , annotation = Nothing
                }
            )
            [ Elm.value
                { importFrom = [ "LamderaRPC" ]
                , name = "StatusBadRequest"
                , annotation = Nothing
                }
            , Elm.string "Generated @rpc endpoints require JSON codec implementation"
            ]
        )
        (Elm.val "model")
        (Elm.get "none" (Elm.val "Cmd"))


{-| Generate if-then-else chain for endpoint routing
-}
generateIfChain : EndpointConfig -> List EndpointConfig -> Elm.Expression
generateIfChain current remaining =
    let
        condition =
            Elm.apply
                (Elm.val "(==)")
                [ Elm.get "endpoint" (Elm.val "args")
                , Elm.string current.name
                ]

        thenBranch =
            Elm.apply
                (Elm.value
                    { importFrom = [ "LamderaRPC" ]
                    , name = "handleEndpointJson"
                    , annotation = Nothing
                    }
                )
                [ Elm.value
                    { importFrom = String.split "." current.moduleName
                    , name = current.functionName
                    , annotation = Nothing
                    }
                , Elm.val "args"
                , Elm.val "model"
                ]

        elseBranch =
            case remaining of
                [] ->
                    -- Last endpoint: return error for unknown
                    Elm.triple
                        (Elm.apply
                            (Elm.value
                                { importFrom = [ "LamderaRPC" ]
                                , name = "failWith"
                                , annotation = Nothing
                                }
                            )
                            [ Elm.value
                                { importFrom = [ "LamderaRPC" ]
                                , name = "StatusBadRequest"
                                , annotation = Nothing
                                }
                            , Elm.apply
                                (Elm.val "(++)")
                                [ Elm.string "Unknown endpoint: "
                                , Elm.get "endpoint" (Elm.val "args")
                                ]
                            ]
                        )
                        (Elm.val "model")
                        (Elm.get "none" (Elm.val "Cmd"))

                next :: rest ->
                    -- More endpoints: recurse
                    generateIfChain next rest
    in
    Elm.ifThen condition thenBranch elseBranch


{-| Generate a list of endpoint names for reference
-}
generateEndpointsList : List EndpointConfig -> Elm.Declaration
generateEndpointsList endpoints =
    Elm.declaration "generatedEndpointNames"
        (Elm.withType (Type.list Type.string)
            (Elm.list (List.map (\e -> Elm.string e.name) endpoints))
        )
        |> Elm.expose
