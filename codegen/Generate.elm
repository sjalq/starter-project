module Generate exposing (main)

{-| RPC Endpoint Generator

Generates RPC wrapper functions from endpoint definitions.

Reads endpoint configurations from endpoints.json (generated by scan-rpc-endpoints.js)

-}

import Elm
import Elm.Annotation as Type
import Gen.Basics
import Gen.CodeGen.Generate as Generate
import Json.Decode as Decode


main : Program Decode.Value () ()
main =
    Generate.fromJson
        decodeEndpoints
        (\endpoints ->
            [ generateRPCEndpoints endpoints
            ]
        )


{-| Endpoint configuration
-}
type alias EndpointConfig =
    { name : String
    , moduleName : String
    , functionName : String
    , paramTypes : List String
    , outputType : String
    , sourceFile : String
    }


{-| JSON decoder for endpoint configurations
-}
decodeEndpoints : Decode.Decoder (List EndpointConfig)
decodeEndpoints =
    Decode.list decodeEndpoint


decodeEndpoint : Decode.Decoder EndpointConfig
decodeEndpoint =
    Decode.map6 EndpointConfig
        (Decode.field "name" Decode.string)
        (Decode.field "moduleName" Decode.string)
        (Decode.field "functionName" Decode.string)
        (Decode.field "paramTypes" (Decode.list Decode.string))
        (Decode.field "outputType" Decode.string)
        (Decode.field "sourceFile" Decode.string)


{-| Generate the RPC endpoints file
-}
generateRPCEndpoints : List EndpointConfig -> Elm.File
generateRPCEndpoints endpoints =
    Elm.file [ "GeneratedRPC" ]
        [ generateRouterFunction endpoints
        , generateEndpointsList endpoints
        ]


{-| Generate the router function that dispatches to endpoints
Generates simple if-then-else chain for routing
-}
generateRouterFunction : List EndpointConfig -> Elm.Declaration
generateRouterFunction endpoints =
    let
        body =
            Elm.functionReduced "rawReq"
                (\rawReq ->
                    Elm.functionReduced "args"
                        (\args ->
                            Elm.functionReduced "model"
                                (\model -> generateRoutingLogic endpoints)
                        )
                )
    in
    Elm.declaration "handleGeneratedEndpoints" body
        |> Elm.expose


{-| Generate routing logic as nested if-then-else expressions
-}
generateRoutingLogic : List EndpointConfig -> Elm.Expression
generateRoutingLogic endpoints =
    case endpoints of
        [] ->
            -- No endpoints: return error
            Elm.triple
                (Elm.apply
                    (Elm.value
                        { importFrom = [ "LamderaRPC" ]
                        , name = "failWith"
                        , annotation = Nothing
                        }
                    )
                    [ Elm.value
                        { importFrom = [ "LamderaRPC" ]
                        , name = "StatusBadRequest"
                        , annotation = Nothing
                        }
                    , Elm.string "No generated endpoints available"
                    ]
                )
                (Elm.val "model")
                (Elm.value
                    { importFrom = [ "Platform", "Cmd" ]
                    , name = "none"
                    , annotation = Nothing
                    }
                )

        first :: rest ->
            -- Generate if-then-else chain
            generateIfChain first rest


{-| Generate if-then-else chain for endpoint routing
-}
generateIfChain : EndpointConfig -> List EndpointConfig -> Elm.Expression
generateIfChain current remaining =
    let
        condition =
            Elm.apply
                (Elm.val "(==)")
                [ Elm.get "endpoint" (Elm.val "args")
                , Elm.string current.name
                ]

        thenBranch =
            Elm.apply
                (Elm.value
                    { importFrom = [ "LamderaRPC" ]
                    , name = "handleEndpointJson"
                    , annotation = Nothing
                    }
                )
                [ Elm.value
                    { importFrom = String.split "." current.moduleName
                    , name = current.functionName
                    , annotation = Nothing
                    }
                , Elm.val "args"
                , Elm.val "model"
                ]

        elseBranch =
            case remaining of
                [] ->
                    -- Last endpoint: return error for unknown
                    Elm.triple
                        (Elm.apply
                            (Elm.value
                                { importFrom = [ "LamderaRPC" ]
                                , name = "failWith"
                                , annotation = Nothing
                                }
                            )
                            [ Elm.value
                                { importFrom = [ "LamderaRPC" ]
                                , name = "StatusBadRequest"
                                , annotation = Nothing
                                }
                            , Elm.apply
                                (Elm.val "(++)")
                                [ Elm.string "Unknown endpoint: "
                                , Elm.get "endpoint" (Elm.val "args")
                                ]
                            ]
                        )
                        (Elm.val "model")
                        (Elm.value
                            { importFrom = [ "Platform", "Cmd" ]
                            , name = "none"
                            , annotation = Nothing
                            }
                        )

                next :: rest ->
                    -- More endpoints: recurse
                    generateIfChain next rest
    in
    Elm.ifThen condition thenBranch elseBranch


{-| Generate a list of endpoint names for reference
-}
generateEndpointsList : List EndpointConfig -> Elm.Declaration
generateEndpointsList endpoints =
    Elm.declaration "generatedEndpointNames"
        (Elm.withType (Type.list Type.string)
            (Elm.list (List.map (\e -> Elm.string e.name) endpoints))
        )
        |> Elm.expose
